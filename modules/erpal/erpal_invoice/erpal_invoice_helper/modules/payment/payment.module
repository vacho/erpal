<?php

/**
 * @file
 * Implements the payment functionality required to create and display an payment entity.
 */

/**
 * Implements hook_entity_info().
 */
function payment_entity_info() {
  $info['payment'] = array(
    'label' => t('Payment'),
    'controller class' => 'PaymentController',
    'base table' => 'payment',
    'uri callback' => 'payment_uri',
    'access callback' => 'payment_access',
    'save callback' => 'payment_save',
    'deletion callback' => 'payment_delete',
    'fieldable' => TRUE,
    'entity keys' => array(
      'id' => 'pid' ,
      'bundle' => 'type',
      'label' => 'subject'
    ),
    'bundle keys' => array(
      'bundle' => 'type',
    ),
    'static cache' => TRUE,
    'bundles' => array(
      'booked_payment' => array(
        'label' => 'Booked payment',
        'admin' => array(
          'path' => 'admin/structure/payment/manage',
          'access arguments' => array('administer payment entities'),
        ),
      ),
    ),
    'view modes' => array(
      'full' => array(
        'label' => t('full'),
        'custom settings' =>  FALSE,
      ),
    )
  );

  return $info;
}

/**
 * Implements hook_views_api().
 */
function payment_views_api() {
  return array(
    'api' => 3,
    'path' => drupal_get_path('module', 'payment') . '/views',
  );
}

/**
 * Implements hook_ctools_plugin_api().
 */
function payment_ctools_plugin_api($owner, $api) {
  if ($owner == 'feeds' && $api == 'feeds_importer_default') {
    return array('version' => 1);
  }
}

/**
 * A hook_feeds_plugins() declares available Fetcher, Parser or Processor
 * plugins to Feeds. For an example look at feeds_feeds_plugin(). For exposing
 * this hook hook_ctools_plugin_api() MUST be implemented, too.
 *
 * @see feeds_feeds_plugin()
 */
function payment_feeds_plugins() {
  $info = array();
  $info['PaymentProcessor'] = array(
    'name' => 'Payment Processor',
    'description' => 'Create and update payments.',
    'help' => 'Create and update payments from parsed content.',
    'handler' => array(
      'parent' => 'FeedsProcessor',
      'class' => 'PaymentProcessor',
      'file' => 'PaymentProcessor.inc',
      'path' => drupal_get_path('module', 'payment') . '/plugins',
    ),
  );
  return $info;
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function payment_ctools_plugin_directory($module, $plugin) {
  if ($module == 'payment' || $module == 'ctools') {
    return 'plugins/' . $plugin;
  }
}


/**
 * Fetch a payment object.
 *
 * This function ends up being a shim between the menu system and
 * payment_load_multiple().
 *
 * @param $pid
 *   Integer specifying the payment id.
 * @param $reset
 *   A boolean indicating that the internal cache should be reset.
 * @return
 *   A fully-loaded $payment object or FALSE if it cannot be loaded.
 *
 * @see payment_load_multiple()
 * @see payment_menu()
 */
function payment_load($pid = NULL, $reset = FALSE) {
  $pids = (isset($pid) ? array($pid) : array());
  $payment = payment_load_multiple($pids, array(), $reset);
  return $payment ? reset($payment) : FALSE;
}

/**
 * Loads multiple payment entities.
 *
 * We only need to pass this request along to entity_load(), which
 * will in turn call the load() method of our entity controller class.
 */
function payment_load_multiple($pids = FALSE, $conditions = array(), $reset = FALSE) {
  $entities = entity_load('payment', $pids, $conditions, $reset);

  // Unserialize settings field if needed.
  foreach ($entities as $entity) {
    if (!is_array($entity->settings)) {
      $entity->settings = unserialize($entity->settings);
    }
  }
  return $entities;
}

/**
 * Implements the uri callback.
 */
function payment_uri($payment) {
  return array(
    'path' => 'payment/' . $payment->pid,
  );
}

/**
 * Implements hook_menu().
 */
function payment_menu() {

  $items['admin/structure/payment/manage'] = array(
    'title' => 'Payments',
    'page callback' => 'payment_list_entities',
    'access arguments' => array('administer payment entities'),
  );

  $items['admin/structure/payment/manage/add'] = array(
    'title' => 'Add Payment',
    'page callback' => 'payment_add',
    'access arguments' => array('create payment entity'),
    'type' => MENU_LOCAL_ACTION,
  );

  // List of all payment entities.
  $items['admin/structure/payment/manage/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  // The page to view our entities - needs to follow what
  // is defined in payment_uri and will use load_payment to retrieve
  // the necessary entity info.
  $items['payment/%payment'] = array(
    'title callback' => 'payment_title',
    'title arguments' => array(1),
    'page callback' => 'payment_view',
    'page arguments' => array(1),
    'access arguments' => array('view payment entity'),
  );

  // 'View' tab for an individual entity page.
  $items['payment/%payment/view'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // 'Edit' tab for an individual entity page.
  $items['payment/%payment/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('payment_form', 1),
    'access arguments' => array('edit payment entity'),
    'type' => MENU_LOCAL_TASK,
  );
  $items['payment/%payment/delete'] = array(
    'title'            => 'Delete',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('payment_delete_form', 1),
    'access arguments' => array('delete payment entity'),
    'type'             => MENU_LOCAL_TASK,
  );
  $items['payment/%payment/remove/%node'] = array(
    'title'            => 'Remove',
    'page callback'    => 'drupal_get_form',
    'page arguments'   => array('payment_remove_invoice_form', 1, 3),
    'access arguments' => array('delete payment entity'),
    'type'             => MENU_LOCAL_TASK,
  );
  $items['payment/add'] = array(
    'title' => 'Add Payment',
    'page callback' => 'payment_add',
    'access arguments' => array('create payment entity'),
  );
  $items['payment/add/%'] = $items['payment/add'];
  $items['payment/add/%']['page arguments'] = array(2);

  return $items;
}

/**
 * Implements hook_permission().
 */
function payment_permission() {
  $permissions = array(
    'administer payment entities' =>  array(
      'title' => t('Administer payment entities'),
    ),
    'view payment entity' => array(
      'title' => t('View payment entity'),
    ),
    'edit payment entity' => array(
      'title' => t('Edit payment entity'),
    ),
    'create payment entity' => array(
      'title' => t('Create payment entity'),
    ),
    'delete payment entity' => array(
      'title' => t('Delete payment entity'),
    ),
  );
  return $permissions;
}

/**
 * Check access for payment entities.
 */
function payment_access($op, $entity, $account) {
  if (user_access('administer payment entities')) {
    return TRUE;
  }
  if (user_access($op .' payment entity')) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Returns a render array with all payment entities.
 */
function payment_list_entities() {
  $content = array();
  // Load all of our entities.
  $entities = payment_load_multiple();
  if (!empty($entities)) {
    foreach ( $entities as $entity ) {
      // Create tabular rows for our entities.
      $rows[] = array(
        'data' => array(
          'id' => $entity->pid,
          'subject' => l($entity->subject, 'payment/' . $entity->pid),
          'bundle' => $entity->type,
        ),
      );
    }
    // Put our entities into a themed table. See theme_table() for details.
    $content['entity_table'] = array(
      '#theme' => 'table',
      '#rows' => $rows,
      '#header' => array(t('ID'), t('Subject'), t('Bundle')),
    );
  }
  else {
    // There were no entities. Tell the user.
    $content[] = array(
      '#type' => 'item',
      '#markup' => t('No payment entities currently exist.'),
    );
  }
  return $content;
}

/**
 * Callback for a page title when this entity is displayed.
 */
function payment_title($entity) {
  return t('Payment: @subject', array('@subject' => $entity->subject));
}

/**
 * Menu callback to display an entity.
 *
 * As we load the entity for display, we're responsible for invoking a number
 * of hooks in their proper order.
 *
 * @see hook_entity_prepare_view()
 * @see hook_entity_view()
 * @see hook_entity_view_alter()
 */
function payment_view($entity, $view_mode = 'full') {
  // Our entity type, for convenience.
  $entity_type = 'payment';
  // Start setting up the content.
  $entity->content = array(
    '#view_mode' => $view_mode,
  );

  field_attach_prepare_view($entity_type, array($entity->pid => $entity),
    $view_mode);

  entity_prepare_view($entity_type, array($entity->pid => $entity));
  // Now field_attach_view() generates the content for the fields.
  $entity->content += field_attach_view($entity_type, $entity, $view_mode);

  $entity->content['date'] = array(
    '#type' => 'item',
    '#title' => t('Created date'),
    '#markup' => format_date($entity->date),
  );
  $entity->content['subject'] = array(
    '#type' => 'item',
    '#title' => t('Subject'),
    '#markup' => $entity->subject,
  );
  $entity->content['value'] = array(
    '#type' => 'item',
    '#title' => t('Value'),
    '#markup' => $entity->value,
  );
  $entity->content['currency'] = array(
    '#type' => 'item',
    '#title' => t('Currency'),
    '#markup' => $entity->currency,
  );

  // Now to invoke some hooks. We need the language code for
  // hook_entity_view(), so let's get that.
  global $language;
  $langcode = $language->language;
  // And now invoke hook_entity_view().
  module_invoke_all('entity_view', $entity, $entity_type, $view_mode,
    $langcode);
  // Now invoke hook_entity_view_alter().
  drupal_alter(array('payment_view', 'entity_view'),
    $entity->content, $entity_type);

  // And finally return the content.
  return $entity->content;
}

/**
 * Implements hook_field_extra_fields().
 */
function payment_field_extra_fields() {
  $form_elements['date'] = array(
    'label' => t('Date'),
    'description' => t('Date (an extra form field)'),
    'weight' => -6,
  );
  $form_elements['subject'] = array(
    'label' => t('Subject'),
    'description' => t('Subject (an extra form field)'),
    'weight' => -5,
  );
  $form_elements['value'] = array(
    'label' => t('Value'),
    'description' => t('Value (an extra form field)'),
    'weight' => -4,
  );
  $form_elements['currency'] = array(
    'label' => t('Currency'),
    'description' => t('Currency (an extra form field)'),
    'weight' => -3,
  );

  $display_elements['date'] = array(
    'label' => t('Date'),
    'description' => t('Creation date (an extra display field)'),
    'weight' => -6,
  );
  $display_elements['subject'] = array(
    'label' => t('Subject'),
    'description' => t('Just like title, but trying to point out that it is a separate property'),
    'weight' => -5,
  );
  $display_elements['value'] = array(
    'label' => t('Value'),
    'description' => t('Value (an extra form field)'),
    'weight' => -4,
  );
  $display_elements['currency'] = array(
    'label' => t('Currency'),
    'description' => t('Currency (an extra form field)'),
    'weight' => -3,
  );

  // Since we have only one bundle type, we'll just provide the extra_fields
  // for it here.
  $extra_fields['payment']['booked_payment']['form'] = $form_elements;
  $extra_fields['payment']['booked_payment']['display'] = $display_elements;

  return $extra_fields;
}

/**
 * Provides a wrapper on the edit form to add a new entity.
 */
function payment_add($invoice_id = 0) {
  // Create a payment entity structure to be used and passed to the validation
  // and submission functions.
  $entity = entity_get_controller('payment')->create();
  return drupal_get_form('payment_form', $entity, $invoice_id);
}

/**
 * Form function to create an payment entity.
 *
 * The pattern is:
 * - Set up the form for the data that is specific to your
 *   entity: the columns of your base table.
 * - Call on the Field API to pull in the form elements
 *   for fields attached to the entity.
 */
function payment_form($form, &$form_state, $entity, $invoice_id = 0) {
  
  if ($invoice_id && is_numeric($invoice_id)) {
    $form['invoice'] = array(
      '#type' => 'value',
      '#value' => $invoice_id,
    );
  }

  $time = isset($entity->date) ? $entity->date : REQUEST_TIME;
  $format = 'Y-m-d';

  $form['date'] = array(
    '#type' => 'date_popup',
    '#date_format' => $format,
    '#title' => t('Date'),
    '#default_value' => date($format, $time),
    '#required' => TRUE,
  );
  $form['subject'] = array(
    '#type' => 'textfield',
    '#title' => t('Subject'),
    '#required' => TRUE,
    '#default_value' => $entity->subject,
  );
  $form['value'] = array(
    '#type' => 'textfield',
    '#title' => t('Value'),
    '#default_value' => isset($entity->value) ? $entity->value : '',
    '#required' => TRUE,
  );
  $form['currency'] = array(
    '#type' => 'select',
    '#title' => t('Currency'),
    '#options' => _billable_get_currencies(),
    '#default_value' => isset($entity->currency) ? $entity->currency : 'EUR',
    '#required' => TRUE,
  );

  $form['payment_entity'] = array(
    '#type' => 'value',
    '#value' => $entity,
  );

  field_attach_form('payment', $entity, $form, $form_state);

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Save'),
    '#weight' => 100,
  );
  $form['delete'] = array(
    '#type' => 'submit',
    '#value' => t('Delete'),
    '#submit' => array('payment_edit_delete'),
    '#weight' => 200,
  );
  return $form;
}


/**
 * Validation handler for payment_add_form form.
 * We pass things straight through to the Field API to handle validation
 * of the attached fields.
 */
function payment_form_validate($form, &$form_state) {
  field_attach_form_validate('payment', $form_state['values']['payment_entity'], $form, $form_state);
}


/**
 * Form submit handler: submits payment_add_form information
 */
function payment_form_submit($form, &$form_state) {
  
  // Add new values to the entity.
  $entity = $form_state['values']['payment_entity'];
  $date = new DateTime($form_state['values']['date']);
  $entity->date = $date->getTimestamp();
  $entity->subject = $form_state['values']['subject'];
  $form_state['values']['value'] = payment_float($form_state['values']['value']);

  // If changed value of payment need reculculetion for all relared billables.
  if (!empty($entity->value) && $entity->value != $form_state['values']['value']) {
    $entity->old_value = $entity->value;
    $saldo = $form_state['values']['value'] - $entity->old_value + $entity->field_saldo[field_language('payment', $entity, 'field_saldo')][0]['value'];
    $entity->field_saldo[field_language('payment', $entity, 'field_saldo')][0]['value'] = $saldo;
    $reculculetion = TRUE;
  }

  // Add new values to the entity.
  $entity->value = $form_state['values']['value'];
  $entity->currency = $form_state['values']['currency'];


  // Add submit for attached fields.
  field_attach_submit('payment', $entity, $form, $form_state);

  // Check if payment value is negative.
  if ($entity->value < 0) {
    $entity->field_negative[field_language('payment', $entity, 'field_negative')][0]['value'] = 1;
    $entity->value = abs($entity->value);
  }

  $insert = empty($entity->pid);
  if ($insert) {
    $entity->field_saldo[field_language('payment', $entity, 'field_saldo')][0]['value'] = $entity->value;
  }
  $entity = payment_save($entity);
  
  // Add notification about add/update payment.
  $link = l(t('view'), 'payment/' . $entity->pid);
  $message_args = array('%subject' => $entity->subject);
  if ($insert) {
    watchdog('payment', 'Payment added %subject.', $message_args, WATCHDOG_NOTICE, $link);
    drupal_set_message(t('Payment %subject has been created.', $message_args));
  }
  else {
    watchdog('payment', 'Payment: updated %subject.', $message_args, WATCHDOG_NOTICE, $link);
    drupal_set_message(t('Payment %subject has been updated.', $message_args));
  }

  // If changed value of payment need reculculetion for all relared billables.
  if (!empty($reculculetion)) {
    payment_update_billables($entity, payment_load_billables($entity), 'update');
  }

  $form_state['redirect'] = 'payment/' . $entity->pid;
  
  // If arg with invoice exist add this payment to invoice.
  if (!empty($form_state['values']['invoice'])) {
    $form_state['values']['invoices'] = array($form_state['values']['invoice']);
    $form_state['values']['payments'] = $entity->pid;
    payment_add_invoices_form_submit($form, $form_state);
  }
}

/**
 * Menu callback -- ask for confirmation of payment deletion.
 */
function payment_delete_form($form, &$form_state, $payment) {
  $form['#payment'] = $payment;
  $form['payment_entity'] = array('#type' => 'value', '#value' => $payment);
  $form['#submit'] = array('payment_edit_delete');

  // If payment already added to some invoice show message about this.
  $message = t('This action cannot be undone.');
  if ($billables = payment_load_billables($payment)) {

    $invoices = array();
    foreach ($billables as $billable_id) {
      $invoices += payment_billable_load_invoices($billable_id);
    }
    if ($invoices) {

      // Get invoices titles.
      $titles = db_select('node')
        ->fields('node', array('nid', 'title'))
        ->condition('nid', $invoices, 'IN')
        ->execute()
        ->fetchAllKeyed();

      // Generate list of invoices.
      $list = array();
      foreach($titles as $nid => $title) {
        $list[] = l($title, 'node/' . $nid);
      }
      $message = t('This action cannot be undone. And this payment used in !list invoices', array('!list' => implode(', ', $list)));
    }
  }
  
  return confirm_form($form,
    t('Are you sure you want to delete %subject?', array('%subject' => $payment->subject)),
    'admin/structure/payment/manage',
    $message,
    t('Delete'),
    t('Cancel')
  );
}

/**
 * Form deletion handler.
 */
function payment_edit_delete($form , &$form_state ) {
  $entity = $form_state['values']['payment_entity'];
  payment_delete($entity);
  drupal_set_message(t('The payment %subject (ID %id) has been deleted',
    array('%subject' => $entity->subject, '%id' => $entity->pid))
  );
  $form_state['redirect'] = 'admin/structure/payment/manage';
}

/**
 * Menu callback -- ask for confirmation of payment removing form invoice.
 */
function payment_remove_invoice_form($form, &$form_state, $payment, $invoice) {
  
  $form['#payment'] = $payment;
  $form['payment_entity'] = array('#type' => 'value', '#value' => $payment);
  $form['#invoice'] = $invoice;
  $form['invoice_entity'] = array('#type' => 'value', '#value' => $invoice);
  $form['#submit'] = array('payment_remove_invoice_submit');
  
  return confirm_form($form,
    t('Are you sure you want to remove %subject payment from %title invoice?', array('%subject' => $payment->subject, '%title' => $invoice->title)),
    'admin/structure/payment/manage',
    t('This action cannot be undone.'),
    t('Remove'),
    t('Cancel')
  );
}

/**
 * Form submit for removing payment from invoice.
 */
function payment_remove_invoice_submit($form , &$form_state) {
  $payment = $form_state['values']['payment_entity'];
  $invoice = $form_state['values']['invoice_entity'];
  $billables_ids = payment_load_billables($payment, $invoice);
  //Update all billables with current payment.
  payment_update_billables($payment, $billables_ids);
  payment_save($payment);
  drupal_set_message(t('The payment %subject has been removed from %invoice',
    array('%subject' => $payment->subject, '%invoice' => $invoice->title))
  );
  $form_state['redirect'] = 'node/' . $invoice->nid;
}

/**
 * We save the entity by calling the controller.
 */
function payment_save(&$entity) {
  return entity_get_controller('payment')->save($entity);
}

/**
 * Use the controller to delete the entity.
 */
function payment_delete($entity) {
  entity_get_controller('payment')->delete($entity);
}

/**
 * Implements hook_entity_presave().
 */
function payment_entity_presave($entity, $type) {
  switch ($type) {

    // Calculation on billable entity save.
    case 'billable':
      $field_saldo = field_get_items($type, $entity, 'field_saldo');
      
      // Check field saldo. If saldo  doesn't exist - assign total price to saldo.
      if (!$field_saldo) {
        $saldo = $entity->total_price;
      }
      else {
        $saldo = $field_saldo[0]['value'];
      }
      // Load payment and run calculation on billable.
      $field_payments = field_get_items($type, $entity, 'field_payments');
      if ($field_payments) {
        foreach ($field_payments as $field_payment) {
          $payment = payment_load($field_payment['target_id'], TRUE);
          $payment_field_saldo = field_get_items('payment', $payment, 'field_saldo');

          // Search payment saldo.
          if (!$payment_field_saldo) {
            $payment_saldo = $payment->value;
          }
          else {
            $payment_saldo = $payment_field_saldo[0]['value'];
          }

          // Check if saldo == 0 and payment saldo have negative value. Only in
          // this case we can continue with saldo = 0.
          if (!$saldo && $payment_saldo >= 0) {
            continue;
          }
          
          // Start calculation.
          if ($saldo < $payment_saldo) {
            $payment_saldo = $payment_saldo - $saldo;
            $price = $saldo;
            $saldo = 0;
          }
          elseif ($saldo > $payment_saldo) {
            $saldo = $saldo - $payment_saldo;
            $price = $payment_saldo;
            $payment_saldo = 0;
          }
          else {
            $price = $saldo;
            $saldo = $payment_saldo = 0;
          }

          // Found id of billable.
          if (!empty($entity->billable_id)) {
            $id = $entity->billable_id;
          }
          else {
            $result = db_query("SHOW TABLE STATUS LIKE 'billable'")->fetchAssoc();
            $id = $result['Auto_increment'];
          }

          // Added price to payment settings.
          if ($price) {
            if (!empty($payment->settings[$id]['price'])) {
              $price = $payment->settings[$id]['price'] + $price;
            }
            $payment->settings[$id] = array(
              'date'  => REQUEST_TIME,
              'title' => $entity->subject,
              'id'    => $id,
              'price' => $price,
            );
          }

          // After calculation save all new values to billable and payment.
          $entity->field_saldo[field_language($type, $entity, 'field_saldo')][0]['value'] = $saldo;
          $payment->field_saldo[field_language('payment', $payment, 'field_saldo')][0]['value'] = $payment_saldo;
          
          // Set Customer of billable as a Payer of payment.
          if (empty($payment->field_payer)) {
            $payment->field_payer[field_language('payment', $payment, 'field_payer')][0]['target_id'] = $entity->customer_nid; 
          }
          
          // Set Service category in payment.
          if (empty($payment->field_service_category_term)) {
            $service = field_get_items($type, $entity, 'field_service_category_term');
            if ($service) {
              $payment->field_service_category_term[field_language('payment', $payment, 'field_service_category_term')][0]['tid'] = $service[0]['tid'];
            }
          }
          payment_save($payment);
        }
      }
      break;
    
    case 'node':
      // Calculation on invoice entity save.
      if ($entity->type == 'erpal_invoice') {
        $field_billables_ref = field_get_items('node', $entity, 'field_billables_ref');
        $saldo = 0;
        if ($field_billables_ref) {
          foreach ($field_billables_ref as $field_billable) {
            $billable = billable_load($field_billable['target_id'], TRUE);
            $field_saldo = field_get_items('billable', $billable, 'field_saldo');
            if (!$field_saldo) {
              $saldo = $saldo + $billable->total_price;
            }
            else {
              $saldo = $saldo + $field_saldo[0]['value'];
            }
          }
          
          if (!empty($entity->update_payment_status)) {
            // If saldo == 0 and invoice not canceled then invoice is already payed.
            $field_payed = field_get_items($type, $entity, 'field_payed');
            if (!$saldo && (!$field_payed || $field_payed[0]['value'] != 2)) {
              $entity->field_payed[field_language($type, $entity, 'field_payed')][0]['value'] = 1;
            } else {
              //otherwise not paid
              $entity->field_payed[field_language($type, $entity, 'field_payed')][0]['value'] = 0;
            }
          }
        }
        $entity->field_saldo[field_language($type, $entity, 'field_saldo')][0]['value'] = $saldo;
      }
      break;
  }
}

/**
 * Load all billables with current payment.
 *
 * @param object $payment
 *   The object of payment entity.
 * @return
 *   as array ids of billables.
 */
function payment_load_billables($payment, $invoice = NULL) {
  if (is_object($payment))
    $pid = $payment->pid;
  else
    $pid = $payment;
  
  $query = db_select('field_data_field_payments', 'payments')
    ->fields('payments', array('entity_id'))
    ->condition('payments.entity_type', 'billable')
    ->condition('payments.field_payments_target_id', $pid);
  if ($invoice) {
    $query->condition('billables.entity_type', 'node');
    $query->condition('billables.entity_id', $invoice->nid);
    $query->leftjoin('field_data_field_billables_ref', 'billables', 'payments.entity_id = billables.field_billables_ref_target_id');
  }
  $result = $query->execute()->fetchCol();

  return $result;

}

/**
 * Load invoices related to this billable.
 *
 * @param int $billable_id
 *   The id of entity billable.
 * @return
 *   as array ids of invoices.
 */
function payment_billable_load_invoices($billable_id) {
  return db_select('field_data_field_billables_ref')
    ->fields('field_data_field_billables_ref', array('entity_id'))
    ->condition('entity_type', 'node')
    ->condition('field_billables_ref_target_id', $billable_id)
    ->execute()
    ->fetchAllKeyed(0, 0);
}

/**
 * Update all billables with current payment.
 *
 * Delete/add payment value in all billables.
 *
 * @param object $payment
 *   The object of payment entity.
 * @param array $billables_ids
 *   as array ids of billables.
 */
function payment_update_billables(&$payment, $billables_ids, $op = 'delete') {
  // Load all needed fields.
  $invoices_ids = array();
  switch ($op) {
    case 'delete':
      $payment_saldo = field_get_items('payment', $payment, 'field_saldo');      
      if ($payment_saldo) {
        $payment_saldo = $payment_saldo[0]['value'];
        $payment_value = $payment->value - $payment_saldo;

        // Calculation for each billable.
        foreach ($billables_ids as $billable_id) {          
          $billable = billable_load($billable_id, TRUE);          
          if ($payment_value) {
            $billable_saldo = field_get_items('billable', $billable, 'field_saldo');
            if ($billable_saldo) {
              $billable_saldo = $billable_saldo[0]['value'];
              $billable_value = $billable->total_price - $billable_saldo;

              if (!empty($payment->settings[$billable_id]['price'])) {
                $price = $payment->settings[$billable_id]['price'];
                $payment_value = $payment_value - $price;
                $billable_saldo = $billable_saldo + $price;
                $payment_saldo = $payment_saldo + $price;
                unset($payment->settings[$billable_id]);
              }

              // Save billable with new values.
              $billable->field_saldo[field_language('billable', $billable, 'field_saldo')][0]['value'] = $billable_saldo;
            }
          }
          // Delete current payment from each billable.
          foreach ($billable->field_payments[field_language('billable', $billable, 'field_payments')] as $key => $value) {
            if ($value['target_id'] == $payment->pid) {
              unset($billable->field_payments[field_language('billable', $billable, 'field_payments')][$key]);
            }
          }
          billable_save($billable);
          // Load invoices related to this billables.
          $invoices_ids += payment_billable_load_invoices($billable_id);
        }
        $payment->field_saldo[field_language('payment', $payment, 'field_saldo')][0]['value'] = $payment_saldo;
      }
      break;
    
    case 'update':
      foreach ($billables_ids as $billable_id) {
        $billable = billable_load($billable_id, TRUE);
        billable_save($billable);
        // Load invoices related to this billables.
        $invoices_ids += payment_billable_load_invoices($billable_id);
      }
      break;
    }
  
  // Recalculation for related invoices.
  if (!empty($invoices_ids)) {
    foreach ($invoices_ids as $invoice_id) {
      $invoice_node = node_load($invoice_id);
      $invoice_node->update_payment_status = true; //this will recalculate the invoice saldo and payment status
      node_save($invoice_node);
      $invoice_node->update_payment_status = false;
    }
  }
}

/**
 * Implements function callback for hook_menu().
 *
 * Form for adding payment to invoices.
 */
function payment_add_invoices_form($form, $form_state, $invoices_default = array(), $payments_default = array()) {
  
  // Load all not payed invoices.
  $query = db_select('node')
    ->fields('node', array('nid', 'title'))
    ->condition('type', 'erpal_invoice')
    ->condition('field_payed_value', 0)
    ->condition('status', 1)
    ->orderBy('created', 'DESC');
  $query->join('field_data_field_payed', 'payed', 'node.nid = payed.entity_id AND node.type = payed.bundle');
  $invoices = $query->execute()->fetchAllKeyed();

  // Load all payments that have saldo > 0.
  $or = db_or()->condition('field_saldo_value', 0, '>')->condition('field_saldo_value', NULL, 'IS NULL');
  $query = db_select('payment')
    ->fields('payment', array('pid', 'subject'))
    ->condition('type', 'booked_payment')
    ->condition($or)
    ->orderBy('date', 'DESC');
  $query->leftjoin('field_data_field_saldo', 'saldo', 'payment.pid = saldo.entity_id AND payment.type = saldo.bundle');
  $payments = $query->execute()->fetchAllKeyed();

  $form['invoices'] = array(
    '#type' => 'select',
    '#title' => t('Invoices'),
    '#options' => $invoices,
    '#multiple' => TRUE,
    '#required' => TRUE,
    '#default_value' => $invoices_default,
    '#description' => t('Please select invoices to which it is needed to add a payment.'),
  );

  $form['payments'] = array(
    '#type' => 'select',
    '#title' => t('Payments'),
    '#options' => $payments,
    '#default_value' => $payments_default,
    '#description' => t('Please select a payment.'),
  );

  $form['submit'] = array(
    '#type'  => 'submit',
    '#value' => t('Add'),
  );
  return $form;
}

/**
 * Submit for import form.
 */
function payment_add_invoices_form_submit($form, &$form_state) {

  // Create batch.
  $batch = array(
    'title'            => t('Add Payment to invoices'),
    'init_message'     => t('Adding'),
    'progress_message' => t('In progress @current from @total'),
    'error_message'    => t('Warning! Error!'),
    'finished'         => 'payment_add_invoices_finished_callback',
  );

  foreach (array_filter($form_state['values']['invoices']) as $invoice) {
    $batch['operations'][] = array('payment_add_invoices_process', array($invoice, $form_state['values']['payments']));
  }

  // Run batch.
  batch_set($batch);
  batch_process();
}

/**
 * Operation for adding payment to invoices.
 */
function payment_add_invoices_process($invoice, $payment, &$context) {
  if (!isset($context['sandbox']['progress'])) {
    $context['sandbox']['progress'] = 0;
    $context['sandbox']['invoice'] = node_load($invoice);
    $context['sandbox']['billables'] = field_get_items('node', $context['sandbox']['invoice'], 'field_billables_ref');

    $context['sandbox']['max'] = count($context['sandbox']['billables']);
  }
  
  if ($context['sandbox']['max'] && !empty($context['sandbox']['billables'][$context['sandbox']['progress']])) {
    $billable_id = $context['sandbox']['billables'][$context['sandbox']['progress']]['target_id'];
    $billable = billable_load($billable_id);
   
    $context['results'][$invoice] = $billable_id;  //add to results list.
   
    $field_payments = field_get_items('billable', $billable, 'field_payments');
    $exists = FALSE;
    if ($field_payments) {
      foreach ($field_payments as $billable_payment) {
        if ($billable_payment['target_id'] == $payment) {
          $exists = TRUE;
        }
      }
    }
    if (!$exists) {
      $billable->field_payments[field_language('billable', $billable, 'field_payments')][]['target_id'] = $payment;
      billable_save($billable);
    }
    $context['sandbox']['progress']++;
    $context['message'] = t('Now processing %billable', array('%billable' => $billable->subject));
    if ($context['sandbox']['progress'] == $context['sandbox']['max']) {
      $invoice_node = $context['sandbox']['invoice'];
      $invoice_node->update_payment_status = TRUE;
      node_save($invoice_node);
      $invoice_node->update_payment_status = FALSE;
    }
  }
  
  if ($context['sandbox']['progress'] != $context['sandbox']['max']) {
    $context['finished'] = $context['sandbox']['progress'] / $context['sandbox']['max'];
  }
}

/**
* function to update the saldo and 
*/

/**
 * Batch finishing callback function.
 */
function payment_add_invoices_finished_callback($success, $results, $operations) {
  if ($success) {
   $message = t('Process finished success');
  }
  else {
    $error_operation = reset($operations);
    $message = t('An error occurred while processing %error_operation with arguments: @arguments',
      array(
        '%error_operation' => $error_operation[0],
        '@arguments' => print_r($error_operation[1], TRUE),
      )
    );
  }
  drupal_set_message($message);
  
  $invoice_nids = array_keys($results);
  $invoice_nid = reset($invoice_nids);
  drupal_goto('node/'.$invoice_nid);
}

/**
 * Implements hook_form_alter
 */
function payment_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    
    // Added pre render for invoice_node_form for disable all billable fields if payment exist.
    case 'erpal_invoice_node_form':
      foreach ($form['field_billables_ref'][field_language('node', $form['#node'], 'field_billables_ref')] as &$field) {
        if (!empty($field['target_id']) && is_array($field['target_id'])) {
          $field['target_id']['#pre_render'] = array('payment_invoice_node_form_pre_render');
        }
      }
    
    case 'billable_edit_form':
      $query = drupal_get_query_parameters();
      if (!empty($query['pids']) && empty($form['field_payments'][field_language('billable', $form_state['billable'], 'field_payments')][0])) {
        foreach ($query['pids'] as  $key => $pid) {
          $payment = payment_load($pid);

          $payment_w = entity_metadata_wrapper('payment', $payment);
          $billable_value = $payment_w->field_saldo->value() ? $payment_w->field_saldo->value() : $payment->value;
          // Added default values.
          $form['subject']['#default_value'] = $payment->subject;
          $form['single_price']['#default_value'] = $billable_value;
 
          $form['single_price']['#title'] = t('Total Price');

          $form['payment_total'] = array(
            '#type' => 'value',
            '#value' => TRUE,
          );
          
          $form['date_delivery']['#default_value'] = date('Y-m-d', $payment->date);
          $form['billed']['#default_value'] = 1;

          // Disable fields which related to calculation of total price.
          //$form['quantity']['#disabled'] = TRUE;
          //$form['single_price']['#disabled'] = TRUE;
          //$form['vat_rate']['#disabled'] = TRUE;

          // Set peyer to customer.
          $field_payer = field_get_items('payment', $payment, 'field_payer');
          if ($field_payer) {
            $form['customer_nid']['#default_value'] = $field_payer[0]['target_id'];
          }

          // If negative payment set to customer global my company.
          $field_negative = field_get_items('payment', $payment, 'field_negative');
          if ($field_negative && $field_negative[0]['value'] == 1) {
            $form['customer_nid']['#default_value'] = variable_get('erpal_config_my_company_nid', FALSE);
          }

          // Set payment to billable.
          $form['field_payments'][field_language('billable', $form_state['billable'], 'field_payments')][$key]['target_id'] = array(
            '#type' => 'value',
            '#value' => $pid,
          );
        }
      }
      // Added validation for check if payment exist.
      $form['#validate'][] = 'payment_billable_validate';
      break;
    case 'payment_add_invoices_form':
      //if a payment id is set but no invoice, show a message that the user should select an invoice   
      if (!empty($form['payments']['#default_value']) && empty($form['invoices']['#default_value'])) {
        drupal_set_message(t('Please select a invoice, where you want to add you payment to.'), 'warning');
      }
      break;
  }
}

/**
 * Form pre render for invoice node form.
 */
function payment_invoice_node_form_pre_render($element) {
  static $disabled = FALSE;
  // If billable has payment we can't change this billable.
  if ($disabled || payment_in_billable_check($element['#value'])) {
    payment_disable_billables_fields($element);
    $disabled = TRUE;
  }
  return $element; 
}

/**
 * Disabling all fields by recursion.
 */
function payment_disable_billables_fields(&$element) {
  if (empty($element['#disabled'])) {
    $element['#disabled'] = TRUE;
    $element['#attributes']['disabled'] = 'disabled';
    if ($children = element_children($element)) {
      foreach ($children as $key) {
        payment_disable_billables_fields($element[$key]);
      }
    }
  }
}

/**
 * Validatin function for delete, add or change billables.
 */
function payment_billable_validate(&$form, &$form_state) {
  $list = array();
  switch ($form_state['values']['form_id']) {
    case 'erpal_invoice_node_form':

      // Check on invoice_node_form submit, if not deleted billables.
      if (isset($form_state['input']['removed_billables'])) {
        $keys = array_keys(array_filter($form_state['input']['removed_billables']));
        $node = (object) $form_state['values'];
        $field_billables_ref = field_get_items('node', $node, 'field_billables_ref');
        $field_billables_ref_values = $node->field_billables_ref_values[field_language('node', $node, 'field_billables_ref')];
        foreach ($keys as $key) {
          if (payment_in_billable_check($field_billables_ref[$key]['target_id'])) {
            $list[] = l($field_billables_ref_values[$key]['widget_values']['subject'], 'billable/' . $field_billables_ref[$key]['target_id'] . '/view');
          }
        }
      }
      break;

    // Check on billable form submit.
    case 'billable_edit_form':
      if (!empty($form_state['values']['payment_total'])) {
        $vat_rate = '0.' . round($form_state['values']['vat_rate']);
        $single_price = $form_state['values']['single_price'] / (1 + $vat_rate);
        form_set_value($form['single_price'], $single_price, $form_state);      
      }
      
      if (payment_in_billable_check($form_state['values']['billable_id'])) {
        $list[] = l($form_state['values']['subject'], 'billable/' . $form_state['values']['billable_id'] . '/view');
      }
      break;
  }
  
  $values = !empty($form_state['values']) ? $form_state['values'] : false;
  $old_billable = !empty($form_state['billable']) ? $form_state['billable'] : false;
  $price_changed = false;
  if ($old_billable) {
    if ($values && $old_billable && $old_billable->quantity != $values['quantity'] || $old_billable->single_price != $values['single_price'] || $old_billable->vat_rate != $values['vat_rate']) {
      $price_changed = true;
    }
  }
  
  if ($list && $price_changed) {
     form_set_error('removed_billables', t('The billables (!list) have already payments added and the price cannot be changed', array('!list' => implode(', ', $list))));
  }
}

/**
 * Check if billable have payment.
 */
function payment_in_billable_check($billable_id) {
  return db_select('field_data_field_payments')
    ->fields('field_data_field_payments', array('field_payments_target_id'))
    ->condition('entity_type', 'billable')
    ->condition('entity_id', $billable_id)
    ->execute()
    ->fetchField();
}

/**
 * Convert all float numbers to one format.
 */
function payment_float($number) {
  if (strpos($number, ',') !== FALSE) {
    return floatval(str_replace(' ', '', str_replace(',', '.', str_replace('.', '', $number))));
  }
  return $number;
}
